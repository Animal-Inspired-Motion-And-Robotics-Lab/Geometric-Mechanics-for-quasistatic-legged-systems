function traj = stitchQuadSE2gaits(in)
%STITCHQUADSE2GAITS given a cell array of gaits, flow inputs, and repetitions for each gait this function stitches everything together into a single trajectory
%   The gait structure to obtained by running "qlevel2noslip_mp.m". Check "se2_GenericQuad_trot.mlx" notebook for more details on setting up the requirements
%   for this function.
%   in = {gaits, input, rep}'; % required input structure
%   numel(gaits) == numel(input) == numel(rep) % required number of elements
%   numel(input{i}) == numel(rep{i}) % for each input time within a gait struct, the number of repetitions and inputs must be equal.
    
    % ensure that the input is compatible
    if ~iscell(in)
        error('ERROR! The gaits to be stitched together must be in a cell array format.');
    end
    if numel(in{1}) ~= numel(in{2})
        error('ERROR! All three input cells need to have the same number of elements.');
    elseif numel(in{2}) ~= numel(in{3})
        error('ERROR! All three input cells need to have the same number of elements.');
    end
    for i = 1:numel(in{1})
        if numel(in{2}{i}) ~= numel(in{3}{i})
            error('ERROR! The number of inputs and number of repetiion elements corresponding to a gait struct should be equal.');
        end
    end
    
    % Unpack
    gaitFamily = in{1}; % gait 'struct's generated by qlevel2noslip_mp.m
    inputs = in{2}; % input that picks out a specific gait
    reps = in{3};   % number of repetitions for each input picked

    % initialize
    traj = [];

    % start computing the net trajectory
    for i = 1:numel(gaitFamily)
        
        % current gaits struct
        data = gaitFamily{i};

        for j = 1:numel(inputs{i})
            
            % find the current gait information
            iX = find(data.u_i == inputs{i}{j}(1)); iY = find(data.u_j == inputs{i}{j}(2));

            % unpack the shape trajectory
            temp_a1_i    = data.gaits{iX, iY}.trajectory{5} ;
            temp_a2_i    = data.gaits{iX, iY}.trajectory{6} ;
            temp_a1_j    = data.gaits{iX, iY}.trajectory{7} ;
            temp_a2_j    = data.gaits{iX, iY}.trajectory{8} ;
            temp_pbq     = data.gaits{iX, iY}.trajectory{9} ;
            temp_phi_tau = data.gaits{iX, iY}.trajectory{14};

            % extend the shape trajectory
            temp_a1_i    = repmat(temp_a1_i,    1, reps{i}{j});
            temp_a2_i    = repmat(temp_a2_i,    1, reps{i}{j});
            temp_a1_j    = repmat(temp_a1_j,    1, reps{i}{j});
            temp_a2_j    = repmat(temp_a2_j,    1, reps{i}{j});
            temp_pbq     = repmat(temp_pbq,     1, reps{i}{j});
            temp_phi_tau = repmat(temp_phi_tau, 1, reps{i}{j});

            % unpack the SE(2) trajectory
            temp_t       = data.gaits{iX, iY}.trajectory{1} ;
            temp_x       = data.gaits{iX, iY}.trajectory{2} ;
            temp_y       = data.gaits{iX, iY}.trajectory{3} ;
            temp_theta   = data.gaits{iX, iY}.trajectory{4} ;
            temp_zx      = data.gaits{iX, iY}.trajectory{15};
            temp_zy      = data.gaits{iX, iY}.trajectory{16};
            temp_ztheta  = data.gaits{iX, iY}.trajectory{17};
            temp_tf      = sum(data.gaits{iX, iY}.periods.phi_tau);

            % check how many gait cycle repetitions are needed and extend the SE(2) trajectory
            if reps{i}{j} > 1
                
                % initialize
                t_temp = temp_t;
                z_1gc = [temp_zx; temp_zy; temp_ztheta]; ztemp = z_1gc;
                b = [temp_x; temp_y; temp_theta]; temp = b;
                
                % iterate a extend for each repetition
                for k = 2:reps{i}{j}
                    % compute next
                    xyztemp = ztemp + rot_SE2(ztemp(3))*temp;   % update trajectory
                    ztemp = ztemp + rot_SE2(ztemp(3))*z_1gc;  % update net displacement
                    t_temp = temp_tf+t_temp;
                    % update current
                    temp_t = [temp_t, t_temp];
                    b = [b, xyztemp];
                end
                temp_x = b(1, :); temp_y = b(2, :); temp_theta = b(3, :); % update trajectory
                temp_zx = ztemp(1); temp_zy = ztemp(2); temp_ztheta = ztemp(3);
                temp_tf = temp_tf*reps{i}{j};

            end

            % update the configuration trajectory
            switch i == 1 && j == 1
                
                case 1 % first stitch
                    
                    % just assign since this is the first stitch
                    t = temp_t;
                    tf = temp_tf;
                    g = [temp_x; temp_y; temp_theta];
                    z = [temp_zx; temp_zy; temp_ztheta];
                    a1_i = temp_a1_i;
                    a2_i = temp_a2_i;
                    a1_j = temp_a1_j;
                    a2_j = temp_a2_j;
                    pbq = temp_pbq;
                    phi_tau = temp_phi_tau;

                case 0 % NOT first stitch

                    t = [t, tf + temp_t];
                    tf = tf + temp_tf;
                    g = [   g, z + rot_SE2(z(3))*[temp_x; temp_y; temp_theta]   ];
                    z = z + rot_SE2(z(3))*[temp_zx; temp_zy; temp_ztheta];
                    a1_i = [a1_i, temp_a1_i];
                    a2_i = [a2_i, temp_a2_j];
                    a1_j = [a1_j, temp_a1_i];
                    a2_j = [a2_j, temp_a2_j];
                    pbq = [pbq, temp_pbq];
                    phi_tau = [phi_tau, temp_phi_tau];

            end

        end
    end

    % Pack the trajectory and return it
    traj.t          = t;
    traj.tf         = tf;
    traj.g          = g;
    traj.z          = z;
    traj.a1_i       = a1_i;
    traj.a2_i       = a2_i;
    traj.a1_j       = a1_j;
    traj.a2_j       = a2_j;
    traj.pbq        = pbq;
    traj.phi_tau    = phi_tau;

end

