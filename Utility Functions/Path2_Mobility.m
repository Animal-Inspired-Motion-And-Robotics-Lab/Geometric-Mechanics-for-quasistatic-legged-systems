% This is a "Path2_Mobility" class for defining paths on level-2 no-slip 
% contact submanifolds for a rigid quadrupedal robot. It takes the initial 
% condition for the shape-space slice (2 dim), gait constraint vector field
% (2 dim), and integration time for the path to construct a Path2 object. 
% It inherits properties from the abstract class "RigidGeomQuad".

classdef Path2_Mobility < RigidGeomQuad

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    properties (SetAccess = private)

        active_state         % the contact state that this path belongs to; an integer in the range (1, 6)
                             % the contact state ordering is as follows {12, 23, 34, 41, 13, 24}

        dz                   % Gait constraint based stratified panel dzij-- [A]*\Vec{d\phi}_{ij}

        dphi                 % Gait constraint vector field dphi_ij-- \Vec{dphi}_{ij}

        ddphi                % Shape(directional)-derivative of the gait constraint vector field-- \Nabla_\alpha \Vec{dphi}_{ij}

        A                    % Local connection vector field-- \boldsymbol{A}_{ij}

        Adot                 % Shape(directional)-derivative of the local connection vector field-- \Nabla_\alpha \boldsymbol{A}_{ij}

        reference_point      % point to analyze mobility from

        int_dirn             % direction to integrate the path along: +phi or -phi with scaling

        int_time             % Integration time in the backward (1) and forward direction (2) from the middle_path

        int_cond             % checks if the pof is on the path, beginning, or at the end of the path

        deadband_dutycycle   % period of time spent swinging in the sub-gait (0 <= val <= 1)
                             % path psi in submanifold + path to return to starting point through the nullspace of the submanifold

        scale_path_method    % method to scale the path about the "reference_point"-- this prop then scales the time vector for the closed length path
                             % and changes the ordering based on final time. Some examples include, 'accln', 'vel'

        initial_condition    % this is the starting point of the path

        final_condition      % this is the ending point of the path

        open_trajectory      % configuration trajectory for the active path

        net_displacement     % the net displacement generated by open/closed trajectories

        path_curvature_traj  % the curvature of the path (\kappa) (1/ radius of curvature) trajectory

        path_net_curvature   % the net curvature of the path (\kappa) (1/ radius of curvature)

        closed_trajectory    % configuration trajectory for the whole subgait (both forward and backward paths)

        open_trajectory_vel  % configuration velocity from the forward path

        closed_trajectory_vel% configuration velocity from the whole subgait

        open_trajectory_acc  % configuration acceleration from the forward path

        closed_trajectory_acc% configuration acceleration from the whole subgait

        path_length          % length of the path

        path_active_color    % color of the trajectory based on the gait constraint color map

        path_inactive_color  % color of the trajectory during the deadband

        path_discretization  % number of points in the active contact state

    end

    methods
        
        % Constructor
        function [thisPath2] = Path2_Mobility( ank, a, l, dzij, dphiij, ddphiij, Aij, Adotij, strpt, t, dc, c, si, dirn )

            % Setup the requirements for the arguments
            arguments
                
                ank     (1, 1) double {mustBeGreaterThan(ank,0.1)}

                a       (1, 1) double {mustBeGreaterThan(a,0.1)}

                l       (1, 1) double {mustBeGreaterThan(l,0.1)}

                dzij    (3, 1) sym    {mustBeA(dzij, 'sym')}

                dphiij  (2, 1) sym    {mustBeA(dphiij, 'sym')}

                ddphiij (2, 2) sym    {mustBeA(ddphiij, 'sym')}

                Aij     (3, 2) sym    {mustBeA(Aij, 'sym')}

                Adotij  (1, 2) cell   {mustBeA(Adotij, 'cell')} % each cell contains a (3,2) symbolic array

                strpt   (1, 2) double {mustBeNumeric}

                t       (1, 2) double {mustBeNonnegative}

                dc      (1, 1) double {mustBeNonnegative, mustBeLessThanOrEqual(dc, 1)}

                c       (2, 3) double {mustBeLessThanOrEqual(c, 1)}

                si      (1, 1) double {mustBePositive, mustBeLessThanOrEqual(si, 6)}

                dirn    (1, 1) double {mustBeLessThanOrEqual(dirn, 1), mustBeGreaterThanOrEqual(dirn, -1)}

            end

            % Get the arguments for a superclass constuctor
            if nargin == 14
                quadArgs = [ank, a, l];
            elseif nargin == 12
                quadArgs = ank;
            elseif nargin == 11
                quadArgs = [];
            else
                error('Error: Need 14, 12, or 11 arguments to create an object.');
            end

            % call the RigidGeometricQuadruped class' constructor
            thisPath2 = thisPath2@RigidGeomQuad(quadArgs);

            % assign the props
            thisPath2.dz = dzij;
            thisPath2.dphi = dphiij;
            thisPath2.ddphi = ddphiij;
            thisPath2.A = Aij;
            thisPath2.Adot = Adotij;
            thisPath2.reference_point = strpt;
            thisPath2.int_time = t;
            thisPath2.deadband_dutycycle = dc;
            thisPath2.path_active_color = c(1,:);
            thisPath2.path_inactive_color = c(2,:);
            thisPath2.active_state = si;
            thisPath2.int_dirn = dirn;

            % increment the number of objects
            Path2.SetGet_static(1);

        end
        
        
    end

    methods (Static)
        
        % static function to icnrement the number of objects
        function out = SetGet_static(~)
            persistent var
            if isempty(var)
                var = 0;
            end
            if nargin == 1
                var = var + 1;
            else
                out = var;
            end
        end

        % Compute the open_trajectory
        function compute_trajectory( thePath2, funcstr, dnum )
        
            % initialize the return container-- we shall return percentages (from -100% to 100% in steps of 10%) of the generated full open_trajectory
            num_scale = 20;
            thePath2.open_trajectory = cell(1,num_scale);
            thePath2.path_length = cell(1,num_scale);
            
            % RigidGeometricQuadruped 's inherited props
            aa = thePath2.get_a; 
            ll = thePath2.get_l;
            
            % check if we want the integration condition
            if numel(thePath2.int_time(thePath2.int_time == 0)) ~= 2                 % make sure some path is needed
                if isempty(thePath2.int_time(thePath2.int_time == 0))                % if both paths are needed
                    cond = 0;                                           
                elseif find(thePath2.int_time == 0) == 1                             % if only the forward path is needed
                    cond = 1;
                elseif find(thePath2.int_time == 0) == 2                             % if only the backward path is needed
                    cond = -1;
                end
            else                                                                     % error if the integration time for both fwd and backward paths are zero.
                error('ERROR: The intergration time in both directions can''t be zero.');
            end
            thePath2.int_cond = cond; % updated the integration property
            
            % integrate the gait constraint ode to obtain the open-trajectory for the system.
            ai0 = thePath2.reference_point(1);  % initial conditions
            aj0 = thePath2.reference_point(2);

            % unpack the integration direction
            dirn = thePath2.int_dirn;
            
            % get the functions needed to integrate-- 'symbolic' datatype to 'matlabFunction' format
            eval(funcstr{1}) % initialize the symbolic variables
            DPHI = matlabFunction(dirn*thePath2.dphi, 'Vars', eval(funcstr{2})); % dirn chooses whether it will be positive or negative
            DQ = [cos(theta), -sin(theta),  0, 0, 0;
                  sin(theta), cos(theta),   0, 0, 0;
                  0,          0,            1, 0, 0;
                  0,          0,            0, 1, 0;
                  0,          0,            0, 0, 1]*[thePath2.dz; thePath2.dphi]*dirn;
            DQ = matlabFunction(DQ, 'Vars', eval(funcstr{3}));                   % configuration vector field

            % integrate
            switch cond
            
                case -1 % just backward path
            
                    tt = linspace(0, thePath2.int_time(1), dnum); % backward-- get the start point of path
                    [~,qb] = ode45( @(t,y) -DPHI(t, aa, ll, y(1), y(2)), tt, [ai0; aj0] );
                    [tf,qf] = ode45( @(t,y) DQ(t, aa, ll, y(1), y(2), y(3), y(4), y(5)), tt, [zeros(3,1); qb(end,1); qb(end,2)] ); % forward to POF
                
                case 0 % both paths
            
                    tt = linspace(0, thePath2.int_time(1), dnum); % backward-- get the start point of path
                    [~,qb] = ode45( @(t,y) -DPHI(t, aa, ll, y(1), y(2)), tt, [ai0; aj0] );
                    tt = linspace(0, sum(thePath2.int_time), dnum); % forward-- integrate the configuration
                    [tf,qf] = ode45( @(t,y) DQ(t, aa, ll, y(1), y(2), y(3), y(4), y(5)), tt, [zeros(3,1); qb(end,1); qb(end,2)] );
            
                case 1 % just forward path
                    
                    tt = linspace(0, thePath2.int_time(2), dnum); % just go forward from POF
                    [tf,qf] = ode45( @(t,y) DQ(t, aa, ll, y(1), y(2), y(3), y(4), y(5)), tt, [zeros(3,1); ai0; aj0] );
            
            end

            % Some more functions for identifying the path curvature
            A     =  matlabFunction(thePath2.A, 'Vars', eval(funcstr{2})); % local connection
            ADOTi = matlabFunction(thePath2.Adot{1}, 'Vars', eval(funcstr{2})); % the directional derivatives of the local connection
            ADOTj = matlabFunction(thePath2.Adot{2}, 'Vars', eval(funcstr{2}));
            DDPSI = matlabFunction(dirn*thePath2.ddphi, 'Vars', eval(funcstr{2})); % the directional derivative of the path constraint
            
            % Here, we shall compute/interpolate and store the positive and negatively scaled gaits ------------------------------------------------------------

            % Get the path velocity & store the open configuration trajectory slice q(s)_ij for the full path
            thePath2.open_trajectory{20} = {tf(:)', qf(:,1)', qf(:,2)', qf(:,3)', qf(:,4)', qf(:,5)'}'; % +100% path
            thePath2.open_trajectory{1} = {tf(:)', fliplr((-qf(end,1) + qf(:,1))'), fliplr((-qf(end,2) + qf(:,2))'), fliplr((-qf(end,3) + qf(:,3))'),...
                fliplr(qf(:,4)'), fliplr(qf(:,5)')}'; % -100% path
            % {x, y, \theta, \alpha_i, \alpha_j}
            Qdot20 = DQ(  thePath2.open_trajectory{20}{1}, aa, ll,...
                thePath2.open_trajectory{20}{2}, thePath2.open_trajectory{20}{3}, thePath2.open_trajectory{20}{4},...
                thePath2.open_trajectory{20}{5}, thePath2.open_trajectory{20}{6}  ); % local configuration velocity
            Qdot1 = DQ(  thePath2.open_trajectory{1}{1}, aa, ll,...
                thePath2.open_trajectory{1}{2}, thePath2.open_trajectory{1}{3}, thePath2.open_trajectory{1}{4},...
                thePath2.open_trajectory{1}{5}, thePath2.open_trajectory{1}{6}  );
            % get the path vel, accln, and curvature information
            [thePath2.path_net_curvature{20}, thePath2.path_curvature_traj{20}, ...
                thePath2.open_trajectory_vel{20}, thePath2.open_trajectory_acc{20}] = ...
                extractPathCurvFromQ2(thePath2.open_trajectory{20}, Qdot20, DDPSI, A, {ADOTi, ADOTj}, {aa, ll});
            [thePath2.path_net_curvature{1}, thePath2.path_curvature_traj{1}, ...
                thePath2.open_trajectory_vel{1}, thePath2.open_trajectory_acc{1}] = ...
                extractPathCurvFromQ2(thePath2.open_trajectory{1}, Qdot1, DDPSI, A, {ADOTi, ADOTj}, {aa, ll});
            % store the initial and final conditions of the path
            thePath2.initial_condition{20} = [thePath2.open_trajectory{20}{5}(1) thePath2.open_trajectory{20}{6}(1)];
            thePath2.final_condition{20} = [thePath2.open_trajectory{20}{5}(end) thePath2.open_trajectory{20}{6}(end)];
            thePath2.initial_condition{1} = [thePath2.open_trajectory{1}{5}(1) thePath2.open_trajectory{1}{6}(1)];
            thePath2.final_condition{1} = [thePath2.open_trajectory{1}{5}(end) thePath2.open_trajectory{1}{6}(end)];
            % compute the net displacement
            thePath2.net_displacement(:,20) = [thePath2.open_trajectory{20}{2}(end), thePath2.open_trajectory{20}{3}(end), thePath2.open_trajectory{20}{4}(end)]';
            thePath2.net_displacement(:,1) = [thePath2.open_trajectory{1}{2}(end), thePath2.open_trajectory{1}{3}(end), thePath2.open_trajectory{1}{4}(end)]';
            % store the closed trajectory
            [thePath2.closed_trajectory{20}, ...
                thePath2.closed_trajectory_vel{20}, thePath2.closed_trajectory_acc{20}] = ...
                thePath2.close_trajectory(thePath2.open_trajectory{20},...
                thePath2.open_trajectory_vel{20}, thePath2.open_trajectory_acc{20}, thePath2.deadband_dutycycle);
            [thePath2.closed_trajectory{1}, ...
                thePath2.closed_trajectory_vel{1}, thePath2.closed_trajectory_acc{1}] = ...
                thePath2.close_trajectory(thePath2.open_trajectory{1},...
                thePath2.open_trajectory_vel{1}, thePath2.open_trajectory_acc{1}, thePath2.deadband_dutycycle);
            % since the gait-constraint vector field has unit magnitude, the path length is just the final time of the path
            thePath2.path_length{20} = thePath2.open_trajectory{20}{1}(end);
            thePath2.path_length{1} = thePath2.open_trajectory{1}{1}(end);
            
            % compute multiples of 10% paths to add to the "open_trajectory" and "path_length" props
            for i = 1:0.5*num_scale-1
                
                iP = 0.5*num_scale + i;     % indices for positively scaled paths
                iN = 0.5*num_scale - i + 1; % indices for negatively scaled paths
                
                % compute interpolated positively scaled paths
                thePath2.open_trajectory{iP} = thePath2.interpolated_open_trajectory(thePath2.open_trajectory{20}, i*0.1, cond, dnum); % compute the scaled path
                QdotP = DQ(  thePath2.open_trajectory{iP}{1}, aa, ll, 0, 0, 0, thePath2.open_trajectory{iP}{5}, thePath2.open_trajectory{iP}{6}  );
                [thePath2.path_net_curvature{iP}, thePath2.path_curvature_traj{iP},...
                    thePath2.open_trajectory_vel{iP}, thePath2.open_trajectory_acc{iP}] = ...
                    extractPathCurvFromQ2(thePath2.open_trajectory{iP}, QdotP, DDPSI, A, {ADOTi, ADOTj}, {aa, ll});
                thePath2.net_displacement(:,iP) = [thePath2.open_trajectory{iP}{2}(end), thePath2.open_trajectory{iP}{3}(end), thePath2.open_trajectory{iP}{4}(end)]';
                [thePath2.closed_trajectory{iP}, ...
                thePath2.closed_trajectory_vel{iP}, thePath2.closed_trajectory_acc{iP}] = ...
                            thePath2.close_trajectory(thePath2.open_trajectory{iP},...
                            thePath2.open_trajectory_vel{iP}, thePath2.open_trajectory_acc{iP}, thePath2.deadband_dutycycle);
                thePath2.path_length{iP} = thePath2.open_trajectory{iP}{1}(end); % get the path length
                thePath2.initial_condition{iP} = [thePath2.open_trajectory{iP}{5}(1) thePath2.open_trajectory{iP}{6}(1)]; % path initial and final conditions
                thePath2.final_condition{iP} = [thePath2.open_trajectory{iP}{5}(end) thePath2.open_trajectory{iP}{6}(end)];
                
                % compute interpolated negatively scaled paths
                thePath2.open_trajectory{iN} = thePath2.interpolated_open_trajectory(thePath2.open_trajectory{1}, i*0.1, cond, dnum);
                QdotN = DQ(  thePath2.open_trajectory{iN}{1}, aa, ll, 0, 0, 0, thePath2.open_trajectory{iN}{5}, thePath2.open_trajectory{iN}{6}  );
                [thePath2.path_net_curvature{iN}, thePath2.path_curvature_traj{iN},...
                    thePath2.open_trajectory_vel{iN}, thePath2.open_trajectory_acc{iN}] = ...
                    extractPathCurvFromQ2(thePath2.open_trajectory{iN}, QdotN, DDPSI, A, {ADOTi, ADOTj}, {aa, ll});
                thePath2.net_displacement(:,iN) = [thePath2.open_trajectory{iN}{2}(end), thePath2.open_trajectory{iN}{3}(end), thePath2.open_trajectory{iN}{4}(end)]';
                [thePath2.closed_trajectory{iN}, ...
                thePath2.closed_trajectory_vel{iN}, thePath2.closed_trajectory_acc{iN}] = ...
                            thePath2.close_trajectory(thePath2.open_trajectory{iN},...
                            thePath2.open_trajectory_vel{iP}, thePath2.open_trajectory_acc{iP}, thePath2.deadband_dutycycle); 
                thePath2.path_length{iN} = thePath2.open_trajectory{iN}{1}(end);
                thePath2.initial_condition{iN} = [thePath2.open_trajectory{iN}{5}(1) thePath2.open_trajectory{iN}{6}(1)];
                thePath2.final_condition{iN} = [thePath2.open_trajectory{iN}{5}(end) thePath2.open_trajectory{iN}{6}(end)];
            end

            % store the path discretization
            thePath2.path_discretization = dnum;
        
        end

        % Compute the open_trajectory-- sliding kind
        function compute_slide_trajectory( thePath2, funcstr, dnum, mul )
        
            % initialize the return container-- we shall return percentages of the slide from 100% to -100%
            num_scale = 21; % the middle gait is first computed and it is slid on both sides
            thePath2.open_trajectory = cell(1,num_scale);
            thePath2.path_length = cell(1,num_scale);
            
            aa = thePath2.get_a; 
            ll = thePath2.get_l;
            
            if numel(thePath2.int_time(thePath2.int_time == 0)) ~= 2
                if isempty(thePath2.int_time(thePath2.int_time == 0))
                    cond = 0;                                           
                elseif find(thePath2.int_time == 0) == 1
                    cond = 1;
                elseif find(thePath2.int_time == 0) == 2
                    cond = -1;
                end
            else
                error('ERROR: The intergration time in both directions can''t be zero.');
            end
            thePath2.int_cond = cond;
            
            ai0 = thePath2.reference_point(1);
            aj0 = thePath2.reference_point(2);
            
            dirn = thePath2.int_dirn;
            
            eval(funcstr{1})
            DPHI = matlabFunction(dirn*thePath2.dphi, 'Vars', eval(funcstr{2}));
            DQ = [cos(theta), -sin(theta),  0, 0, 0;
                  sin(theta), cos(theta),   0, 0, 0;
                  0,          0,            1, 0, 0;
                  0,          0,            0, 1, 0;
                  0,          0,            0, 0, 1]*[thePath2.dz; thePath2.dphi]*dirn;
            DQ = matlabFunction(DQ, 'Vars', eval(funcstr{3}));
            
            switch cond
            
                case -1
            
                    tt = linspace(0, mul(1)*thePath2.int_time(1), dnum);
                    [~,qb] = ode45( @(t,y) -DPHI(t, aa, ll, y(1), y(2)), tt, [ai0; aj0] );
                    [tf,qf] = ode45( @(t,y) DQ(t, aa, ll, y(1), y(2), y(3), y(4), y(5)), tt, [zeros(3,1); qb(end,1); qb(end,2)] );
                
                case 0
            
                    tt = linspace(0, mul(1)*thePath2.int_time(1), dnum);
                    [~,qb] = ode45( @(t,y) -DPHI(t, aa, ll, y(1), y(2)), tt, [ai0; aj0] );
                    tt = linspace(0, sum(mul.*thePath2.int_time), dnum);
                    [tf,qf] = ode45( @(t,y) DQ(t, aa, ll, y(1), y(2), y(3), y(4), y(5)), tt, [zeros(3,1); qb(end,1); qb(end,2)] );
            
                case 1
                    
                    tt = linspace(0, mul(2)*thePath2.int_time(2), dnum);
                    [tf,qf] = ode45( @(t,y) DQ(t, aa, ll, y(1), y(2), y(3), y(4), y(5)), tt, [zeros(3,1); ai0; aj0] );
            
            end
            
            A     =  matlabFunction(thePath2.A, 'Vars', eval(funcstr{2}));
            ADOTi = matlabFunction(thePath2.Adot{1}, 'Vars', eval(funcstr{2}));
            ADOTj = matlabFunction(thePath2.Adot{2}, 'Vars', eval(funcstr{2}));
            DDPSI = matlabFunction(dirn*thePath2.ddphi, 'Vars', eval(funcstr{2}));

            Qfull = {tf(:)', qf(:,1)', qf(:,2)', qf(:,3)', qf(:,4)', qf(:,5)'}'; % the configuration path over the full slide range!!
            Qdotfull = DQ(  Qfull{1}, aa, ll,...
                Qfull{2}, Qfull{3}, Qfull{4},...
                Qfull{5}, Qfull{6}  );
            idxNom = ceil(num_scale/2); t0 = (mul(1) - 1)*thePath2.int_time(1); tPi = t0 + sum(thePath2.int_time); tNom = linspace(t0, tPi, dnum);
            thePath2.open_trajectory{idxNom} = configInterp(tNom, Qfull); % +0% slid path (nominal)
            [thePath2.path_net_curvature{idxNom}, thePath2.path_curvature_traj{idxNom}, ...
                thePath2.open_trajectory_vel{idxNom}, thePath2.open_trajectory_acc{idxNom}] = ...
                extractPathCurvFromQ2(Qfull, Qdotfull, DDPSI, A, {ADOTi, ADOTj}, {aa, ll}); % curvature, vel, and accln for the path above
            thePath2.initial_condition{idxNom} = [thePath2.open_trajectory{idxNom}{5}(1) thePath2.open_trajectory{idxNom}{6}(1)];
            thePath2.final_condition{idxNom} = [thePath2.open_trajectory{idxNom}{5}(end) thePath2.open_trajectory{idxNom}{6}(end)];
            thePath2.net_displacement(:,idxNom) = [thePath2.open_trajectory{idxNom}{2}(end), thePath2.open_trajectory{idxNom}{3}(end), thePath2.open_trajectory{idxNom}{4}(end)]';
            [thePath2.closed_trajectory{idxNom}, ...
                thePath2.closed_trajectory_vel{idxNom}, thePath2.closed_trajectory_acc{idxNom}] = ...
                thePath2.close_trajectory(thePath2.open_trajectory{idxNom},...
                thePath2.open_trajectory_vel{idxNom}, thePath2.open_trajectory_acc{idxNom}, thePath2.deadband_dutycycle);
            thePath2.path_length{idxNom} = thePath2.open_trajectory{idxNom}{1}(end);
            slide_perct = linspace(-1, 1, num_scale);
            for i = [1:idxNom-1, idxNom+1:num_scale]
                    t0Now = (1- slide_perct(i))*(mul(1) - 1)*thePath2.int_time(1); tPiNow = t0Now + sum(thePath2.int_time); tNow = linspace(t0Now, tPiNow, dnum);
                    thePath2.open_trajectory{i} = configInterp(tNow, Qfull);
                    QdotNow = DQ(  thePath2.open_trajectory{i}{1}, aa, ll,...
                        thePath2.open_trajectory{i}{2}, thePath2.open_trajectory{i}{3}, thePath2.open_trajectory{i}{4},...
                        thePath2.open_trajectory{i}{5}, thePath2.open_trajectory{i}{6}  );
                    [thePath2.path_net_curvature{i}, thePath2.path_curvature_traj{i}, ...
                        thePath2.open_trajectory_vel{i}, thePath2.open_trajectory_acc{i}] = ...
                        extractPathCurvFromQ2(thePath2.open_trajectory{i}, QdotNow, DDPSI, A, {ADOTi, ADOTj}, {aa, ll});
                    thePath2.initial_condition{i} = [thePath2.open_trajectory{i}{5}(1) thePath2.open_trajectory{i}{6}(1)];
                    thePath2.final_condition{i} = [thePath2.open_trajectory{i}{5}(end) thePath2.open_trajectory{i}{6}(end)];
                    thePath2.net_displacement(:,i) = [thePath2.open_trajectory{i}{2}(end), thePath2.open_trajectory{i}{3}(end), thePath2.open_trajectory{i}{4}(end)]';
                    [thePath2.closed_trajectory{i}, ...
                        thePath2.closed_trajectory_vel{i}, thePath2.closed_trajectory_acc{i}] = ...
                        thePath2.close_trajectory(thePath2.open_trajectory{i},...
                thePath2.open_trajectory_vel{i}, thePath2.open_trajectory_acc{i}, thePath2.deadband_dutycycle);
                    thePath2.path_length{i} = thePath2.open_trajectory{i}{1}(end);
            end
            thePath2.path_discretization = dnum;
        
        end
        
        % This function computes different percentages of the 
        % open-trajectory by keeping "path_start" prop constant, and using 
        % interp1 with the spline method.
        function q_interp = interpolated_open_trajectory(fullPath2, p, cond, dnum)
            % unpack your open_trajectory
            t = fullPath2{1};
            x = fullPath2{2};
            y = fullPath2{3};
            theta = fullPath2{4};
            ai = fullPath2{5};
            aj = fullPath2{6};
            % get the limitng points
            switch cond
                case -1
                    leftpt = numel(t) - floor(p*numel(t)); rightpt = numel(t);
                case  0
                    midpt = ceil(numel(t)/2);
                    leftpt = midpt - p*(midpt-1); rightpt = midpt + p*(midpt-1);
                case  1
                    leftpt = 1; rightpt = ceil(p*numel(t));
            end
            % get the modified trajectory
            t_temp = t(leftpt:rightpt); t_temp = t_temp - t_temp(1);
            x_temp = x(leftpt:rightpt); x_temp = x_temp - x_temp(1);
            y_temp = y(leftpt:rightpt); y_temp = y_temp - y_temp(1);
            theta_temp = theta(leftpt:rightpt); theta_temp = theta_temp - theta_temp(1);
            ai_temp = ai(leftpt:rightpt);
            aj_temp = aj(leftpt:rightpt);
            % interpolate to a desired discretization
            T = linspace(t_temp(1), t_temp(end), dnum);
            X = interp1(t_temp, x_temp, T, 'pchip');
            Y = interp1(t_temp, y_temp, T, 'pchip');
            THETA = interp1(t_temp, theta_temp, T, 'pchip');
            AI = interp1(t_temp, ai_temp, T, 'pchip');
            AJ = interp1(t_temp, aj_temp, T, 'pchip');
            % return the solution
            q_interp = {T(:)', X(:)', Y(:)', THETA(:)', AI(:)', AJ(:)'}';
        end
        
        
    end
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
end